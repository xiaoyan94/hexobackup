---
title: JVM 04
date: 2020-07-11 17:02:59
tags: [JVM,Java]
---

## 1 堆的核心概述

* ● 一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。
* ● Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。
  * ➢ 堆内存的大小是可以调节的。
* ● 《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
* ● 所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区 (ThreadLocal Allocation Buffer， TLAB)

一个 JVM 实例对应一个进程，方法区和堆是一个进程一份，而程序计数器、本地方法栈、虚拟机栈是一个线程对应一份，一个进程中的所有线程共享方法区和堆（并不是完整的堆都一定是共享的，比如 TLAB）。

<!-- more -->

### 内存细分

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：

Java 7 及之前堆内存逻辑上分为三部分：新生区 + 养老区 +**永久区**

* ➢ Young Generation Space 新生区 Young/New  
  * 又被划分为 Eden 区和 Survivor 区
* ➢ Tenure generation space 养老区 0ld/Tenure
* ➢ Permanent Space 永久区 Perm

Java 8 及之后堆内存逻辑上分为三部分：新生区 + 养老区 +**元空间**

* ➢ Young Generation Space 新生区 Young/New
  * 又被划分为 Eden 区和 Survivor 区
* ➢ Tenure generation space 养老区 0ld/Tenure
* ➢ Meta Space 元空间 Meta

约定：新生区 / 新生代 / 年轻代、养老区 / 老年区 / 老年代、永久区 / 永久代

![堆空间内部结构](堆空间内部结构.png)

![永久代和元空间](永久代和元空间.jpeg)

演示 JVM 实例：

```java
package com.atguigu.java;

/**
 * -Xms10m -Xmx10m
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  16:41
 */
public class HeapDemo {
    public static void main (String [] args) {
        System.out.println ("start...");
        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }

        System.out.println ("end...");
    }

}
```

---

```java
package com.atguigu.java;

/**
 * -Xms20m -Xmx20m
 * @author shkstart  shkstart@126.com
 * @create 2020  16:42
 */
public class HeapDemo1 {
    public static void main (String [] args) {
        System.out.println ("start...");
        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }

        System.out.println ("end...");
    }
}
```

在 Idea 中，依次点击 `Run` - `Edit Configurations` 在 `VM options` 中输入参数 `-Xms20m -Xmx20m`。然后打开 [Visual VM](https://visualvm.github.io/)，这个软件在 JDK 1.8 以后就不再内置，需要 [手动下载](https://visualvm.github.io/download.html)， 在 `Tools` - `Plugins` 中安装 `Visual GC` 插件。

![HeapDemo Overview](HeapDemo0.png)

从上图中可以看到设置的 JVM 内存参数。

![HeapDemo](HeapDemo.png)

![HeapDemo1](HeapDemo1.png)

从以上图中可以看到，伊甸园区、两个幸存者区、老年区加起来正好是我们设置的总内存大小 20M。

---

* 《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated )
  * ➢ 我要说的是：“几乎” 所有的对象实例都在这里分配内存。—— 从实际使用角度看的。
* 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
* 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
* 堆，是 GC ( Garbage Collection, 垃圾收集器）执行垃圾回收的重点区域。

```java
package com.atguigu.java;

/**
 * @author shkstart  shkstart@126.com
 * @create 2020  17:28
 */
public class SimpleHeap {
    private int id;// 属性、成员变量

    public SimpleHeap (int id) {
        this.id = id;
    }

    public void show () {
        System.out.println ("My ID is" + id);
    }
    public static void main (String [] args) {
        SimpleHeap sl = new SimpleHeap (1);
        SimpleHeap s2 = new SimpleHeap (2);

        int [] arr = new int [10];

        Object [] arr1 = new Object [10];
    }
}
```

设置 VM 参数：`-Xms10m -Xmx10m -XX:+PrintGCDetails` , 在 JDK1.8 下运行 SimpleHeap

```java
Heap
 PSYoungGen      total 2560K, used 1406K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 2048K, 68% used [0x00000007bfd00000,0x00000007bfe5fbe8,0x00000007bff00000)
  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)
 ParOldGen       total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000)
 Metaspace       used 2950K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K
```

在 JDK1.7 下运行：

```java
Heap
 PSYoungGen      total 3072K, used 1176K [0x00000007ffc80000, 0x0000000800000000, 0x0000000800000000)
  eden space 2560K, 45% used [0x00000007ffc80000,0x00000007ffda6258,0x00000007fff00000)
  from space 512K, 0% used [0x00000007fff80000,0x00000007fff80000,0x0000000800000000)
  to   space 512K, 0% used [0x00000007fff00000,0x00000007fff00000,0x00000007fff80000)
 ParOldGen       total 7168K, used 0K [0x00000007ff580000, 0x00000007ffc80000, 0x00000007ffc80000)
  object space 7168K, 0% used [0x00000007ff580000,0x00000007ff580000,0x00000007ffc80000)
 PSPermGen       total 21504K, used 2859K [0x00000007fa380000, 0x00000007fb880000, 0x00000007ff580000)
  object space 21504K, 13% used [0x00000007fa380000,0x00000007fa64af68,0x00000007fb880000)

Process finished with exit code 0
```

可以看到，JDK1.8 以后就是元空间了。

![局部变量表、堆、方法区](SimpleHeap.png)

对象、数组在堆中创建，局部变量表中只保留对他们的引用。

---

## 2 设置堆内存大小与 0OM

### 堆空间大小的设置

* Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项 "`-Xmx`" 和”`-Xms`" 来进行设置。
  * ➢“`-Xms`" 用于表示堆区的起始内存，等价于 `-XX: InitialHeapSize`
  * ➢“`-Xmx`" 则用于表示堆区的最大内存，等价于 `-XX :MaxHeapSize`
* 一旦堆区中的内存大小超过 “`-Xmx`" 所指定的最大内存时，将会抛出 `OutOfMemoryError` 异常。
* 通常会将 `-Xms` 和 `-Xmx` 两个参数配置相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
* 默认情况下，初始内存大小：物理电脑内存大小 / 64
* 最大内存大小：物理电脑内存大小 / 4

`-X` 参数用法：<https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html>

```java
package com.atguigu.java;

/**
 * 1. 设置堆空间大小的参数
 * -Xms 用来设置堆空间（年轻代 + 老年代）的初始内存大小
 *      -X 是 jvm 的运行参数
 *      ms 是 memory start
 * -Xmx 用来设置堆空间（年轻代 + 老年代）的最大内存大小
 *
 * 2. 默认堆空间的大小
 *    初始内存大小：物理电脑内存大小 / 64
 *             最大内存大小：物理电脑内存大小 / 4
 * 3. 手动设置：-Xms600m -Xmx600m
 *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。
 *
 * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程 id
 *                  方式二：-XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  20:15
 */
public class HeapSpaceInitial {
    public static void main (String [] args) {

        // 返回 Java 虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime ().totalMemory () / 1024 / 1024;
        // 返回 Java 虚拟机试图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime ().maxMemory () / 1024 / 1024;

        System.out.println ("-Xms :" + initialMemory + "M");
        System.out.println ("-Xmx :" + maxMemory + "M");

        // 默认设置时，即不设置虚拟机参数使用默认分配内存大小
//        System.out.println ("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");
//        System.out.println ("系统内存大小为：" + maxMemory * 4.0 / 1024 + "G");

        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
```

程序输出：

```java
-Xms : 575M
-Xmx : 575M
```

为什么输出结果不是设置的 600M？

```bash
  jps
32736
49124 Launcher
49125 HeapSpaceInitial
49161 Jps
34013 Main
  jstat -gc 49125
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
25600.0 25600.0  0.0    0.0   153600.0 15360.5   409600.0     0.0     4480.0 780.7  384.0   76.6       0    0.000   0      0.000   -          -    0.000
```

通过下面两个柿子：

1. 25600 (S0C) + 25600 (S1C) + 153600 (EC) + 409600 (OC) = 614400, 614400 ÷ 1024 = 600
2. 25600 (S0C/S1C) + 153600 (EC) + 409600 (OC) = 588800, 588800 ÷ 1024 = 575

可知，575 为两个幸存者区其中一个幸存者区 + 伊甸园区 + 老年区的大小总和。

也可以使用 `-XX:+PrintGCDetails` 查看：

```java
-Xms : 575M
-Xmx : 575M
Heap
 PSYoungGen      total 179200K, used 9216K [0x00000007b3800000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 153600K, 6% used [0x00000007b3800000,0x00000007b41001a0,0x00000007bce00000)
  from space 25600K, 0% used [0x00000007be700000,0x00000007be700000,0x00000007c0000000)
  to   space 25600K, 0% used [0x00000007bce00000,0x00000007bce00000,0x00000007be700000)
 ParOldGen       total 409600K, used 0K [0x000000079a800000, 0x00000007b3800000, 0x00000007b3800000)
  object space 409600K, 0% used [0x000000079a800000,0x000000079a800000,0x00000007b3800000)
 Metaspace       used 2953K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 321K, capacity 388K, committed 512K, reserved 1048576K
```

179200K = 153600K + 25600K ，年轻代总大小为伊甸园区 + 一个幸存者 (from 或 to) 区的大小。

### `OutOfMemoryError` 的说明与举例

演示程序：

```java
package com.atguigu.java;

import java.util.ArrayList;
import java.util.Random;

/**
 * -Xms600m -Xmx600m
 * @author shkstart  shkstart@126.com
 * @create 2020  21:12
 */
public class OOMTest {
    public static void main (String [] args) {
        ArrayList<Picture> list = new ArrayList<>();
        while (true){
            try {
                Thread.sleep (20);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            list.add (new Picture (new Random ().nextInt (1024 * 1024)));
        }
    }
}

class Picture {
    private byte [] pixels;

    public Picture (int length) {
        this.pixels = new byte [length];
    }
}
```

程序最终肯定会输出异常信息：

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
  at com.atguigu.java.Picture.<init>(OOMTest.java:29)
  at com.atguigu.java.OOMTest.main (OOMTest.java:20)
```

在 Visual VM 中，通过 Visual GC 可以动态监控堆内存变化情况，通过 Sampler - Memory 还可以分析是什么原因导致堆内存溢出异常。

![VisualVM - Visual GC](VisualVM.gif)
![VisualVM - Sampler - Memory](VisualVMSampler.png)

---

## 3 年轻代与老年代

* 存储在 JVM 中的 Java 对象可以被划分为两类：
  * ➢ 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  * ➢ 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致。
* Java 堆区进一步细分的话，可以划分为年轻代 (YoungGen) 和老年代 (OldGen)
* 其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）。

![堆空间内部结构划分](HeapMemoryDivision.png)

下面这参数开发中一般不会调：

配置新生代与老年代在堆结构的占比。

* ➢ 默认 `-XX:NewRatio=2`，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3
* ➢ 可以修改 `-XX:NewRatio=4`，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5

测试：

```java
package com.atguigu.java1;

/**
 * -Xms600m -Xmx600m
 *
 * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是 2.
 * -XX:SurvivorRatio ：设置新生代中 Eden 区与 Survivor 区的比例。默认值是 8
 * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）
 * -Xmn: 设置新生代的空间的大小。 （一般不设置）
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  17:23
 */
public class EdenSurvivorTest {
    public static void main (String [] args) {
        System.out.println ("我只是来打个酱油～");
        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
```

设置 VM Option 参数：`-Xms600m -Xmx600m` ，可以使用 `jinfo` 命令查看 `NewRatio` 参数：

```bash
 ✘  yan  ~  jps #jps
32736
34013 Main
53645 Launcher
54110 Jps
53646 EdenSurvivorTest
  yan  ~  jinfo -flag NewRatio 53646 #jinfo
-XX:NewRatio=2
  yan  ~  jinfo -flag SurvivorRatio 53646
-XX:SurvivorRatio=8
```

使用不同的参数运行程序进行测试，得到下表：

参数 | Eden Space | Survivor 0 | Survivor 1 | Old Gen | SurvivorRatio | NewRatio
---|------------|------------|------------|---------|---------------|---------
`-Xms600m -Xmx600m` | 150 | 25 | 25 | 400 | 6 | 2
`-Xms600m -Xmx600m -XX:-UseAdaptiveSizePolicy` | 150 | 25 | 25 | 400 | 6 | 2
`-Xms600m -Xmx600m -XX:SurvivorRatio=8` | 160 | 20 | 20 | 400 | 8 | 2
`-Xms600m -Xmx600m -XX:SurvivorRatio=8 -XX:NewRatio=3` | 120 | 15 | 15 | 450 | 8 | 3

虽然默认的 `SurvivorRatio` 是 8，官方文档也是 8，但是实际运行中伊甸园区和幸存者区的比例是 150:25 = 6:1，即使使用 `-XX:-UseAdaptiveSizePolicy` ：关闭自适应的内存分配策略，也还是 6:1。除非显式地使用 `-XX:SurvivorRatio=8` 显式指定比例为 8:1

* 在 HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是 8:1:1
* 当然开发人员可以通过选项 “`-XX:SurvivorRatio`" 调整这个空间比例。比如 `-XX:SurvivorRatio=8`
* **几乎所有** 的 Java 对象都是在 Eden 区被 new 出来的。
* 绝大部分的 Java 对象的销毁都在新生代进行了。
  * ➢ IBM 公司的专门研究表明，新生代中 80% 的对象都是 “朝生夕死” 的。
* 可以使用选项 "`-Xmn`" 设置新生代最大内存大小
* ➢这个参数一般使用默认值就可以了。

![年轻代与老年代的关系](Survivor.png)

[参考文档：Plumbr Handbook Java Garbage Collection.pdf](Plumbr%20Handbook%20Java%20Garbage%20Collection.pdf)

---

## 4 图解对象分配过程

为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。

1. new 的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收 (Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。
3. 然后将伊甸园区中的剩余对象移动到幸存者 0 区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。
5. 如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。
6. 啥时候能去养老区呢？可以设置次数。默认是 15 次。
   * 可以设置参数: `-XX:MaxTenuringThreshold=<N>` 进行设置。

![新生代对象内存分配与回收过程](新生代对象内存分配与回收过程.png)

当伊甸园区满的时候，会触发 YGC/MinorGC，会将伊甸园区和幸存者区 (from 区) 一起回收。但是幸存者区满的时候不会触发 YGC/MinorGC。

总结：

**针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to**。

**关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区 / 元空间收集**。

对象分配特殊情况：

![对象分配特殊情况](对象分配特殊情况.png)

代码举例与 JVisualVM 演示对象的分配过程：

```java
package com.atguigu.java1;

import java.util.ArrayList;
import java.util.Random;

/**
 * -Xms600m -Xmx600m
 * @author shkstart  shkstart@126.com
 * @create 2020  17:51
 */
public class HeapInstanceTest {
    byte [] buffer = new byte [new Random ().nextInt (1024 * 200)];

    public static void main (String [] args) {
        ArrayList<HeapInstanceTest> list = new ArrayList<HeapInstanceTest>();
        while (true) {
            list.add (new HeapInstanceTest ());
            try {
                Thread.sleep (10);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
```

VisualVM - Visual GC：

![查看年轻区、老年区各时间段内存占用对应的图像走势](VisualVMVisualGC.png)

最后，堆空间中老年区满，没有可用空间来为对象继续分配内存，程序会异常终止：

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
 at com.atguigu.java1.HeapInstanceTest.<init>(HeapInstanceTest.java:12)
 at com.atguigu.java1.HeapInstanceTest.main (HeapInstanceTest.java:17)
```

常用调优工具：

* JDK 命令行：`jmap`, `jinfo`, `jstat`,`javap` 等
* Eclipse : Memory Analyzer Tool
* Jconsole
* VisualVM
* Jprofiler
* Java Flight Recorder
* GCViewer
* GC Easy

[在 `Idea` 中配置 `JProfiler`](https://blog.csdn.net/wytocsdn/article/details/79258247)：

1. 安装 JProfiler：官网下载安装 <https://www.ej-technologies.com/download/jprofiler/files>
2. 安装 JProfiler Idea 插件：在 `Idea` 插件市场搜索 JProfiler 安装，在插件设置中设置 JProfiler 目录。
3. 点击 `Run` 旁边的 JProfiler 图标运行。

---

## 5 Minor GC、Major GC、Full GC

JVM 在进行 GC 时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集
(Partial GC)，一种是整堆收集 (Full GC)

* 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为:
  * ➢ 新生代收集 (Minor GC / Young GC) : 只是新生代的垃圾收集
  * ➢ 老年代收集 (Major GC / Old GC) : 只是老年代的垃圾收集。
    * 目前，只有 CMS GC 会有单独收集老年代的行为。
    * *注意，很多时候 Major GC 会和 Fu1l GC 混淆使用，需要具体分辨是老年代回收还是整堆回收*。
  * ➢ 混合收集 (Mixed GC): 收集整个新生代以及部分老年代的垃圾收集。
    * 目前，只有 G1 GC 会有这种行为
* 整堆收集 (Full GC): 收集整个 java 堆和方法区的垃圾收集。

---

## 6 堆空间分代思想

---

## 7 内存分配策略

---

## 8 为对象分配内存：TLAB

---

## 9 小结堆空间的参数设置

---

## X 堆是分配对象的唯一选择吗
