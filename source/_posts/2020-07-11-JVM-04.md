---
title: JVM 04
date: 2020-07-11 17:02:59
tags: [JVM,Java]
---

## 1 堆的核心概述

* ● 一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。
* ● Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。
  * ➢ 堆内存的大小是可以调节的。
* ● 《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
* ● 所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区 (ThreadLocal Allocation Buffer， TLAB)

一个 JVM 实例对应一个进程，方法区和堆是一个进程一份，而程序计数器、本地方法栈、虚拟机栈是一个线程对应一份，一个进程中的所有线程共享方法区和堆（并不是完整的堆都一定是共享的，比如 TLAB）。

<!-- more -->

### 内存细分

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：

Java 7 及之前堆内存逻辑上分为三部分：新生区 + 养老区 +**永久区**

* ➢ Young Generation Space 新生区 Young/New  
  * 又被划分为 Eden 区和 Survivor 区
* ➢ Tenure generation space 养老区 0ld/Tenure
* ➢ Permanent Space 永久区 Perm

Java 8 及之后堆内存逻辑上分为三部分：新生区 + 养老区 +**元空间**

* ➢ Young Generation Space 新生区 Young/New
  * 又被划分为 Eden 区和 Survivor 区
* ➢ Tenure generation space 养老区 0ld/Tenure
* ➢ Meta Space 元空间 Meta

约定：新生区 / 新生代 / 年轻代、养老区 / 老年区 / 老年代、永久区 / 永久代

![堆空间内部结构](堆空间内部结构.png)

![永久代和元空间](永久代和元空间.jpeg)

演示 JVM 实例：

```java
package com.atguigu.java;

/**
 * -Xms10m -Xmx10m
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  16:41
 */
public class HeapDemo {
    public static void main (String [] args) {
        System.out.println ("start...");
        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }

        System.out.println ("end...");
    }

}
```

---

```java
package com.atguigu.java;

/**
 * -Xms20m -Xmx20m
 * @author shkstart  shkstart@126.com
 * @create 2020  16:42
 */
public class HeapDemo1 {
    public static void main (String [] args) {
        System.out.println ("start...");
        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }

        System.out.println ("end...");
    }
}
```

在 Idea 中，依次点击 `Run` - `Edit Configurations` 在 `VM options` 中输入参数 `-Xms20m -Xmx20m`。然后打开 [Visual VM](https://visualvm.github.io/)，这个软件在 JDK 1.8 以后就不再内置，需要 [手动下载](https://visualvm.github.io/download.html)， 在 `Tools` - `Plugins` 中安装 `Visual GC` 插件。

![HeapDemo Overview](HeapDemo0.png)

从上图中可以看到设置的 JVM 内存参数。

![HeapDemo](HeapDemo.png)

![HeapDemo1](HeapDemo1.png)

从以上图中可以看到，（JDK1.8 下运行时）伊甸园区、**两个幸存者区**、老年区加起来正好是我们设置的总内存大小 20M。（实测JDK1.7 下运行时，伊甸园区、*一个幸存者区*、老年区加起来是 20M）

---

* 《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated )
  * ➢ 我要说的是：“几乎” 所有的对象实例都在这里分配内存。—— 从实际使用角度看的。
* 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
* 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
* 堆，是 GC ( Garbage Collection, 垃圾收集器）执行垃圾回收的重点区域。

```java
package com.atguigu.java;

/**
 * @author shkstart  shkstart@126.com
 * @create 2020  17:28
 */
public class SimpleHeap {
    private int id;// 属性、成员变量

    public SimpleHeap (int id) {
        this.id = id;
    }

    public void show () {
        System.out.println ("My ID is" + id);
    }
    public static void main (String [] args) {
        SimpleHeap sl = new SimpleHeap (1);
        SimpleHeap s2 = new SimpleHeap (2);

        int [] arr = new int [10];

        Object [] arr1 = new Object [10];
    }
}
```

设置 VM 参数：`-Xms10m -Xmx10m -XX:+PrintGCDetails` , 在 JDK1.8 下运行 SimpleHeap

```java
Heap
 PSYoungGen      total 2560K, used 1406K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 2048K, 68% used [0x00000007bfd00000,0x00000007bfe5fbe8,0x00000007bff00000)
  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)
 ParOldGen       total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000)
 Metaspace       used 2950K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K
```

在 JDK1.7 下运行：

```java
Heap
 PSYoungGen      total 3072K, used 1176K [0x00000007ffc80000, 0x0000000800000000, 0x0000000800000000)
  eden space 2560K, 45% used [0x00000007ffc80000,0x00000007ffda6258,0x00000007fff00000)
  from space 512K, 0% used [0x00000007fff80000,0x00000007fff80000,0x0000000800000000)
  to   space 512K, 0% used [0x00000007fff00000,0x00000007fff00000,0x00000007fff80000)
 ParOldGen       total 7168K, used 0K [0x00000007ff580000, 0x00000007ffc80000, 0x00000007ffc80000)
  object space 7168K, 0% used [0x00000007ff580000,0x00000007ff580000,0x00000007ffc80000)
 PSPermGen       total 21504K, used 2859K [0x00000007fa380000, 0x00000007fb880000, 0x00000007ff580000)
  object space 21504K, 13% used [0x00000007fa380000,0x00000007fa64af68,0x00000007fb880000)

Process finished with exit code 0
```

可以看到，JDK1.8 以后就是元空间了。

![局部变量表、堆、方法区](SimpleHeap.png)

对象、数组在堆中创建，局部变量表中只保留对他们的引用。

---

## 2 设置堆内存大小与 0OM

### 堆空间大小的设置

* Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项 "`-Xmx`" 和”`-Xms`" 来进行设置。
  * ➢“`-Xms`" 用于表示堆区的起始内存，等价于 `-XX: InitialHeapSize`
  * ➢“`-Xmx`" 则用于表示堆区的最大内存，等价于 `-XX :MaxHeapSize`
* 一旦堆区中的内存大小超过 “`-Xmx`" 所指定的最大内存时，将会抛出 `OutOfMemoryError` 异常。
* 通常会将 `-Xms` 和 `-Xmx` 两个参数配置相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
* 默认情况下，初始内存大小：物理电脑内存大小 / 64
* 最大内存大小：物理电脑内存大小 / 4

`-X` 参数用法：<https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html>

```java
package com.atguigu.java;

/**
 * 1. 设置堆空间大小的参数
 * -Xms 用来设置堆空间（年轻代 + 老年代）的初始内存大小
 *      -X 是 jvm 的运行参数
 *      ms 是 memory start
 * -Xmx 用来设置堆空间（年轻代 + 老年代）的最大内存大小
 *
 * 2. 默认堆空间的大小
 *    初始内存大小：物理电脑内存大小 / 64
 *             最大内存大小：物理电脑内存大小 / 4
 * 3. 手动设置：-Xms600m -Xmx600m
 *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。
 *
 * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程 id
 *                  方式二：-XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  20:15
 */
public class HeapSpaceInitial {
    public static void main (String [] args) {

        // 返回 Java 虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime ().totalMemory () / 1024 / 1024;
        // 返回 Java 虚拟机试图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime ().maxMemory () / 1024 / 1024;

        System.out.println ("-Xms :" + initialMemory + "M");
        System.out.println ("-Xmx :" + maxMemory + "M");

        // 默认设置时，即不设置虚拟机参数使用默认分配内存大小
//        System.out.println ("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");
//        System.out.println ("系统内存大小为：" + maxMemory * 4.0 / 1024 + "G");

        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
```

程序输出：

```java
-Xms : 575M
-Xmx : 575M
```

为什么输出结果不是设置的 600M？

```bash
  jps
32736
49124 Launcher
49125 HeapSpaceInitial
49161 Jps
34013 Main
  jstat -gc 49125
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
25600.0 25600.0  0.0    0.0   153600.0 15360.5   409600.0     0.0     4480.0 780.7  384.0   76.6       0    0.000   0      0.000   -          -    0.000
```

通过下面两个柿子：

1. 25600 (S0C) + 25600 (S1C) + 153600 (EC) + 409600 (OC) = 614400, 614400 ÷ 1024 = 600
2. 25600 (S0C/S1C) + 153600 (EC) + 409600 (OC) = 588800, 588800 ÷ 1024 = 575

可知，575 为两个幸存者区其中一个幸存者区 + 伊甸园区 + 老年区的大小总和。

也可以使用 `-XX:+PrintGCDetails` 查看：

```java
-Xms : 575M
-Xmx : 575M
Heap
 PSYoungGen      total 179200K, used 9216K [0x00000007b3800000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 153600K, 6% used [0x00000007b3800000,0x00000007b41001a0,0x00000007bce00000)
  from space 25600K, 0% used [0x00000007be700000,0x00000007be700000,0x00000007c0000000)
  to   space 25600K, 0% used [0x00000007bce00000,0x00000007bce00000,0x00000007be700000)
 ParOldGen       total 409600K, used 0K [0x000000079a800000, 0x00000007b3800000, 0x00000007b3800000)
  object space 409600K, 0% used [0x000000079a800000,0x000000079a800000,0x00000007b3800000)
 Metaspace       used 2953K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 321K, capacity 388K, committed 512K, reserved 1048576K
```

179200K = 153600K + 25600K ，年轻代总大小为伊甸园区 + 一个幸存者 (from 或 to) 区的大小。

### `OutOfMemoryError` 的说明与举例

演示程序：

```java
package com.atguigu.java;

import java.util.ArrayList;
import java.util.Random;

/**
 * -Xms600m -Xmx600m
 * @author shkstart  shkstart@126.com
 * @create 2020  21:12
 */
public class OOMTest {
    public static void main (String [] args) {
        ArrayList<Picture> list = new ArrayList<>();
        while (true){
            try {
                Thread.sleep (20);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            list.add (new Picture (new Random ().nextInt (1024 * 1024)));
        }
    }
}

class Picture {
    private byte [] pixels;

    public Picture (int length) {
        this.pixels = new byte [length];
    }
}
```

程序最终肯定会输出异常信息：

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
  at com.atguigu.java.Picture.<init>(OOMTest.java:29)
  at com.atguigu.java.OOMTest.main (OOMTest.java:20)
```

在 Visual VM 中，通过 Visual GC 可以动态监控堆内存变化情况，通过 Sampler - Memory 还可以分析是什么原因导致堆内存溢出异常。

![VisualVM - Visual GC](VisualVM.gif)
![VisualVM - Sampler - Memory](VisualVMSampler.png)

---

## 3 年轻代与老年代

* 存储在 JVM 中的 Java 对象可以被划分为两类：
  * ➢ 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  * ➢ 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致。
* Java 堆区进一步细分的话，可以划分为年轻代 (YoungGen) 和老年代 (OldGen)
* 其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）。

![堆空间内部结构划分](HeapMemoryDivision.png)

下面这参数开发中一般不会调：

配置新生代与老年代在堆结构的占比。

* ➢ 默认 `-XX:NewRatio=2`，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3
* ➢ 可以修改 `-XX:NewRatio=4`，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5

测试：

```java
package com.atguigu.java1;

/**
 * -Xms600m -Xmx600m
 *
 * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是 2.
 * -XX:SurvivorRatio ：设置新生代中 Eden 区与 Survivor 区的比例。默认值是 8
 * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）
 * -Xmn: 设置新生代的空间的大小。 （一般不设置）
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  17:23
 */
public class EdenSurvivorTest {
    public static void main (String [] args) {
        System.out.println ("我只是来打个酱油～");
        try {
            Thread.sleep (1000000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
```

设置 VM Option 参数：`-Xms600m -Xmx600m` ，可以使用 `jinfo` 命令查看 `NewRatio` 参数：

```bash
 ✘  yan  ~  jps #jps
32736
34013 Main
53645 Launcher
54110 Jps
53646 EdenSurvivorTest
  yan  ~  jinfo -flag NewRatio 53646 #jinfo
-XX:NewRatio=2
  yan  ~  jinfo -flag SurvivorRatio 53646
-XX:SurvivorRatio=8
```

使用不同的参数运行程序进行测试，得到下表：

参数 | Eden Space | Survivor 0 | Survivor 1 | Old Gen | SurvivorRatio | NewRatio
---|------------|------------|------------|---------|---------------|---------
`-Xms600m -Xmx600m` | 150 | 25 | 25 | 400 | 6 | 2
`-Xms600m -Xmx600m -XX:-UseAdaptiveSizePolicy` | 150 | 25 | 25 | 400 | 6 | 2
`-Xms600m -Xmx600m -XX:SurvivorRatio=8` | 160 | 20 | 20 | 400 | 8 | 2
`-Xms600m -Xmx600m -XX:SurvivorRatio=8 -XX:NewRatio=3` | 120 | 15 | 15 | 450 | 8 | 3

虽然默认的 `SurvivorRatio` 是 8，官方文档也是 8，但是实际运行中伊甸园区和幸存者区的比例是 150:25 = 6:1，即使使用 `-XX:-UseAdaptiveSizePolicy` ：关闭自适应的内存分配策略，也还是 6:1。除非显式地使用 `-XX:SurvivorRatio=8` 显式指定比例为 8:1

* 在 HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是 8:1:1
* 当然开发人员可以通过选项 “`-XX:SurvivorRatio`" 调整这个空间比例。比如 `-XX:SurvivorRatio=8`
* **几乎所有** 的 Java 对象都是在 Eden 区被 new 出来的。
* 绝大部分的 Java 对象的销毁都在新生代进行了。
  * ➢ IBM 公司的专门研究表明，新生代中 80% 的对象都是 “朝生夕死” 的。
* 可以使用选项 "`-Xmn`" 设置新生代最大内存大小
* ➢这个参数一般使用默认值就可以了。

![年轻代与老年代的关系](Survivor.png)

[参考文档：Plumbr Handbook Java Garbage Collection.pdf](Plumbr%20Handbook%20Java%20Garbage%20Collection.pdf)

---

## 4 图解对象分配过程

为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。

1. new 的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收 (Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。
3. 然后将伊甸园区中的剩余对象移动到幸存者 0 区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。
5. 如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。
6. 啥时候能去养老区呢？可以设置次数。默认是 15 次。
   * 可以设置参数: `-XX:MaxTenuringThreshold=<N>` 进行设置。

![新生代对象内存分配与回收过程](新生代对象内存分配与回收过程.png)

当伊甸园区满的时候，会触发 YGC/MinorGC，会将伊甸园区和幸存者区 (from 区) 一起回收。但是幸存者区满的时候不会触发 YGC/MinorGC。

总结：

**针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to**。

**关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区 / 元空间收集**。

对象分配特殊情况：

![对象分配特殊情况](对象分配特殊情况.png)

代码举例与 JVisualVM 演示对象的分配过程：

```java
package com.atguigu.java1;

import java.util.ArrayList;
import java.util.Random;

/**
 * -Xms600m -Xmx600m
 * @author shkstart  shkstart@126.com
 * @create 2020  17:51
 */
public class HeapInstanceTest {
    byte [] buffer = new byte [new Random ().nextInt (1024 * 200)];

    public static void main (String [] args) {
        ArrayList<HeapInstanceTest> list = new ArrayList<HeapInstanceTest>();
        while (true) {
            list.add (new HeapInstanceTest ());
            try {
                Thread.sleep (10);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
```

VisualVM - Visual GC：

![查看年轻区、老年区各时间段内存占用对应的图像走势](VisualVMVisualGC.png)

最后，堆空间中老年区满，没有可用空间来为对象继续分配内存，程序会异常终止：

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
 at com.atguigu.java1.HeapInstanceTest.<init>(HeapInstanceTest.java:12)
 at com.atguigu.java1.HeapInstanceTest.main (HeapInstanceTest.java:17)
```

常用调优工具：

* JDK 命令行：`jmap`, `jinfo`, `jstat`,`javap` 等
* Eclipse : Memory Analyzer Tool
* Jconsole
* VisualVM
* Jprofiler
* Java Flight Recorder
* GCViewer
* GC Easy

[在 `Idea` 中配置 `JProfiler`](https://blog.csdn.net/wytocsdn/article/details/79258247)：

1. 安装 JProfiler：官网下载安装 <https://www.ej-technologies.com/download/jprofiler/files>
2. 安装 JProfiler Idea 插件：在 `Idea` 插件市场搜索 JProfiler 安装，在插件设置中设置 JProfiler 目录。
3. 点击 `Run` 旁边的 JProfiler 图标运行。

---

## 5 Minor GC、Major GC、Full GC

JVM 在进行 GC 时，并非每次都对上面三个内存区域（新生代、老年代、方法区）一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集 (Partial GC)，一种是整堆收集 (Full GC)

* 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为:
  * ➢ 新生代收集 (Minor GC / Young GC) : 只是新生代（Eden、s0、s1）的垃圾收集
  * ➢ 老年代收集 (Major GC / Old GC) : 只是老年代的垃圾收集。
    * 目前，只有 CMS GC 会有单独收集老年代的行为。
      * *注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收*。
  * ➢ 混合收集 (Mixed GC): 收集整个新生代以及部分老年代的垃圾收集。
    * 目前，只有 G1 GC 会有这种行为
* 整堆收集 (Full GC): 收集整个 java 堆和方法区的垃圾收集。

---

### 最简单的分代式GC策略的触发条件

* ● **年轻代 GC (Minor GC ) 触发机制**:
  * ➢ 当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。(每次 Minor GC 会清理年轻代的内存。)
  * ➢ 因为 Java**对象大多都具备朝生夕灭的特性**，所以 MinorGC 非常频繁，一般回收速度也比较快。这一 - 定义既清晰又易于理解。
  * ➢ Minor GC 会引发 STW， 暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

* ● **老年代 GC (Major GC/Full GC) 触发机制**:
  * ➢ 指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC" 或 “Full GC” 发生了。
  * ➢ 出现了 Major GC， 经常会伴随至少一次的 Minor GC (但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程)。
    * 也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足，则触发 Major GC
  * ➢ Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长。
  * ➢ 如果 Major GC 后，内存还不足，就报 `OOM` 了。

* ● **Full GC 触发机制: (后面细讲)**  
触发 Full GC 执行的情况有如下五种:  
  * (1) 调用 `System.gc()` 时，系统建议执行 **Full GC**，但是不必然执行
  * (2) 老年代空间不足
  * (3) 方法区空间不足
  * (4) 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存
  * (5) 由 Eden 区、survivor space0 (From Space) 区向 survivor space1 (To Space) 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

  说明: **Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些**。

### GC举例与日志分析

测试代码：

```java
package com.atguigu.java1;

import java.util.ArrayList;
import java.util.List;

/**
 * 测试MinorGC 、 MajorGC、FullGC
 * -Xms9m -Xmx9m -XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  14:19
 */
public class GCTest {
    public static void main(String[] args) {
        int i = 0;
        try {
            List<String> list = new ArrayList<>();
            String a = "atguigu.com";
            while (true) {
                list.add(a);
                a = a + a;
                i++;
            }

        } catch (Throwable t) {
            t.printStackTrace();
            System.out.println("遍历次数为：" + i);
        }
    }
}
```

设置 VM options，运行：

```java
[GC (Allocation Failure) [PSYoungGen: 2036K->496K(2560K)] 2036K->871K(9728K), 0.0062912 secs] [Times: user=0.01 sys=0.01, real=0.00 secs]
[GC (Allocation Failure) [PSYoungGen: 1964K->480K(2560K)] 2340K->1682K(9728K), 0.0017672 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
[GC (Allocation Failure) [PSYoungGen: 1941K->160K(2560K)] 3144K->2770K(9728K), 0.0017537 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
[Full GC (Ergonomics) [PSYoungGen: 1008K->0K(2560K)] [ParOldGen: 6834K->4588K(7168K)] 7843K->4588K(9728K), [Metaspace: 3012K->3012K(1056768K)], 0.0051738 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]
[GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] 4588K->4588K(9728K), 0.0009531 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] [ParOldGen: 4588K->4570K(7168K)] 4588K->4570K(9728K), [Metaspace: 3012K->3012K(1056768K)], 0.0038536 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]
遍历次数为：16
Heap
 PSYoungGen      total 2560K, used 136K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 2048K, 6% used [0x00000007bfd00000,0x00000007bfd22300,0x00000007bff00000)
  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)
 ParOldGen       total 7168K, used 4570K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
  object space 7168K, 63% used [0x00000007bf600000,0x00000007bfa76938,0x00000007bfd00000)
 Metaspace       used 3086K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 337K, capacity 388K, committed 512K, reserved 1048576K
java.lang.OutOfMemoryError: Java heap space
 at java.util.Arrays.copyOf(Arrays.java:3332)
 at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)
 at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)
 at java.lang.StringBuilder.append(StringBuilder.java:136)
 at com.atguigu.java1.GCTest.main(GCTest.java:20)

Process finished with exit code 0
```

*分析*：

`[GC (Allocation Failure) [PSYoungGen: 2036K->496K(2560K)] 2036K->871K(9728K), 0.0062912 secs] [Times: user=0.01 sys=0.01, real=0.00 secs]`

年轻代GC：GC前年轻代 2036K，GC后年轻代496K (年轻代总大小2560K, 2.5M)；GC前堆2036K，GC后堆871K（堆总大小9728K, 9.5M 包括老年代）

GC后年轻代大小没有变成 0K，因为有一部分对象保存在幸存者区没有被垃圾回收。

`[Full GC (Ergonomics) [PSYoungGen: 1008K->0K(2560K)] [ParOldGen: 6834K->4588K(7168K)] 7843K->4588K(9728K), [Metaspace: 3012K->3012K(1056768K)], 0.0051738 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]`

Full GC：GC前年轻代1008K，GC后年轻代0K （年轻代总大小2560K，2.5M）；GC前老年代6834K，GC后老年代4588K （老年代总大小7168K，7M）；GC前堆7834K，GC后堆4588K （堆总大小 9728K, 9.5M ）

```plain
Heap
 PSYoungGen      total 2560K, used 136K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 2048K, 6% used [0x00000007bfd00000,0x00000007bfd22300,0x00000007bff00000)
  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)
 ParOldGen       total 7168K, used 4570K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
  object space 7168K, 63% used [0x00000007bf600000,0x00000007bfa76938,0x00000007bfd00000)
 Metaspace       used 3086K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 337K, capacity 388K, committed 512K, reserved 1048576K
```

年轻代2560K，2.5M ；伊甸园区2M，from、to各0.5M  
老年代7168K，7 M  

🤔🤔从上面日志可以看出，堆空间实际上大于设置的参数9M❓

---

<iframe width="1015" height="549" src="https://www.youtube.com/embed/vY-gi_7M_Mc?list=PLtGk8Nqe2ZcK0xUtbQjHeX2gqgoOdKJnX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## 6 堆空间分代思想

为什么需要对 Java 堆进行分代？不分代就不能正常工作了吗？

* 经研究，不同对象的生命周期不同。70%-99% 的对象是临时对象。
  * ➢ 新生代：有 Eden、两块大小相同的 Survivor (又称为 from/to， s0/s1) 构成，to 总为空。
  * ➢ 老年代：存放新生代中经历多次 GC 仍然存活的对象。
* 其实不分代完全可以，分代的唯一理由就是优化 Gc 性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方， 当 GC 的时候先把这块存储 “朝生夕死” 对象的区域进行回收，这样就会腾出很大的空间出来。

---

## 7 内存分配策略

如果对象在 Eden 出生并经过第次 MinorGC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 survivor 空间中，并将对象年龄设为 1。对象在 Survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定
程度 (默认为 15 岁，其实每个 JVM、每个 GC 都有所不同) 时，就会被晋升到老年代中。

对象晋升老年代的年龄阈值，可以通过选项 `-XX:MaxTenuringThreshold` 来设置

针对不同年龄段的对象分配原则如下所示:

* ● 优先分配到 Eden
* ● 大对象直接分配到老年代
  * 尽量避免程序中出现过多的大对象
* ● 长期存活的对象分配到老年代
* ● 动态对象年龄判断
  * 如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，**年龄大于或等于**该年龄的对象可以直接进入老年代，无须等到 `MaxTenuringThreshold` 中要求的年龄。
* ● 空间分配担保
  * `-XX:HandlePromotionFailure`

测试：大对象直接分配到老年代

```java
package com.atguigu.java1;

/** 测试：大对象直接进入老年代
 * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  21:48
 */
public class YoungOldAreaTest {
    public static void main(String[] args) {
        byte[] buffer = new byte[1024 * 1024 * 20];//20m

    }
}
```

设置 VM options 为 `-Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails` ，在 Java 8 下运行：

```java
Heap
 PSYoungGen      total 18432K, used 2308K [0x00000007bec00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 16384K, 14% used [0x00000007bec00000,0x00000007bee41048,0x00000007bfc00000)
  from space 2048K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007c0000000)
  to   space 2048K, 0% used [0x00000007bfc00000,0x00000007bfc00000,0x00000007bfe00000)
 ParOldGen       total 40960K, used 20480K [0x00000007bc400000, 0x00000007bec00000, 0x00000007bec00000)
  object space 40960K, 50% used [0x00000007bc400000,0x00000007bd800010,0x00000007bec00000)
 Metaspace       used 3080K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 337K, capacity 388K, committed 512K, reserved 1048576K

```

在 JDK1.7 下运行结果如下：

```java
Heap
 PSYoungGen      total 18432K, used 1967K [0x00000007fec00000, 0x0000000800000000, 0x0000000800000000)
  eden space 16384K, 12% used [0x00000007fec00000,0x00000007fedebc28,0x00000007ffc00000)
  from space 2048K, 0% used [0x00000007ffe00000,0x00000007ffe00000,0x0000000800000000)
  to   space 2048K, 0% used [0x00000007ffc00000,0x00000007ffc00000,0x00000007ffe00000)
 ParOldGen       total 40960K, used 20480K [0x00000007fc400000, 0x00000007fec00000, 0x00000007fec00000)
  object space 40960K, 50% used [0x00000007fc400000,0x00000007fd800010,0x00000007fec00000)
 PSPermGen       total 21504K, used 2986K [0x00000007f7200000, 0x00000007f8700000, 0x00000007fc400000)
  object space 21504K, 13% used [0x00000007f7200000,0x00000007f74eab58,0x00000007f8700000)
```

设置了堆空间最小 / 大为 60M，新生代与老年代之间的比例为 2:1，伊甸园区与幸存者区之间的比例为 8:1:1，打印 GC 日志详情。新生代（伊甸园区 16M + 两个幸存者区 2M*2）20M，老年代 40M，老年代已用空间 20M，由此可见，伊甸园区容纳不下 20M 的数组，分配的一个 20M 的数组直接进入了老年代。

---

## 8 为对象分配内存：TLAB

**为什么有 TLAB ( Thread Local Allocation Buffer )** ?

* ● 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
* ● 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
* ● 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

**什么是 TLAB** ?

* 从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM **为每个线程分配了一个私有缓存区域**，它包含在 Eden 空间内。
* 多线程同时分配内存时，使用 TLAB 可以避免一系列的~~非~~线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为**快速分配**策略。
* 据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。

**TLAB 的再说明**:

* 尽管不是所有的对象实例都能够在 TLAB 中成功分配内存 (因为空间很小)，但 **JVM 确实是将 TLAB 作为内存分配的首选** （使用命令 `jinfo -flag UseTLAB pid` 查看 TLAB 是否开启，默认是开启的）。
* 在程序中，开发人员可以通过选项 “`-XX:UseTLAB`" 设置是否开启 TLAB 空间。
* 默认情况下，TLAB 空间的内存非常小，**仅占有整个 Eden 空间的 1%**，可以使用命令 `jinfo -flag TLABWasteTargetPercent pid` 查看 TLAB 占伊甸园区的百分比，当然我们可以通过选项 [“`-XX:TLABWasteTargetPercent`"](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html) 设置 TLAB 空间所占用 Eden 空间的百分比大小。
* 一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着 **通过使用加锁机制** 确保数据操作的原子性，从而直接在 Eden 空间中分配内存。

![对象分配过程：TLAB](TLAB.png)

---

## 9 小结堆空间的参数设置

堆空间的参数设置

官网说明：<https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html>

* `-XX:+PrintFlagsInitial` : 查看所有的参数的默认初始值
* `-XX:+PrintFlagsFinal` : 查看所有的参数的最终值 (可能会存在修改，不再是初始值)
* `-Xms` : 初始堆空间内存 ( 默认为物理内存的 1/64)
* `-Xmx` : 最大堆空间内存 ( 默认为物理内存的 1/4)
* `-Xmn` : 设置新生代的大小。(初始值及最大值)
* `-XX:NewRatio` : 配置新生代与老年代在堆结构的占比
* `-XX:SurvivorRatio` : 设置新生代中 Eden 和 S0/S1 空间的比例
* `-XX:MaxTenuringThreshold` : 设置新生代垃圾的最大年龄
* `-XX:+PrintGCDetails` : 输出详细的 GC 处理日志
  * ➢ 打印 GC 简要信息: ① `-XX:+PrintGC` ② `-verbose:gc`
* `-XX:HandlePromotionFailure` : 是否设置空间分配担保

**关于参数** `-XX:SurvivorRatio`

年轻代中，若伊甸园区设置过大，幸存者区较小，则容易导致在 YGC / Minor GC 时，伊甸园区中剩余的对象直接晋升老年代，则分代的意义就不大了。

若伊甸园区设置过小，幸存者区过大，则容易导致 YGC / Minor GC 的频率增加，更加频繁的垃圾回收会增加 STW 的总体时间，影响程序的性能。

从性能调优的角度，都应该降低 GC 的频率。

**关于参数** `-XX:HandlePromotionFailure`

在发生 Minor GC 之前，虚拟机会**检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**。

* 如果大于，则此次 Minor GC 是安全的
* 如果小于，则虚拟机会查看 `-XX:HandlePromotionFailure` 设置值是否允许担保失败。
  * 如果 `HandlePromotionFailure`=true， 那么会继续**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
    * 如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的；
    * 如果小于，则改为进行一次 Full GC。
  * 如果 `HandlePromotionFailure`=false， 则改为进行一次 Full GC。

在 JDK6 Update24 之后，HandlePromotionFailure 参数不会再影响到虛拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update24 之后的规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC， 否则将进行 Full GC**。

---

## X 堆是分配对象的唯一选择吗

**堆是分配对象的唯一选择吗** ？

在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述:

随着 JIT 编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “绝对” 了。

在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过**逃逸分析 (Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM, 其中创新的 GCIH (GC invisible heap) 技术实现 off-heap, 将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。

### 逃逸分析概述

* 如何将堆上的对象分配到栈，需要使用逃逸分析手段。
* 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
* 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
* 逃逸分析的基本行为就是分析对象动态作用域:;
  * ➢ 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
  * ➢ 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

例如：

```java
public void my_method(){
    V v = new V();
    // use v
    // ...
    v = null;
}
```

没有发生逃逸的现象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。

由例如，

```java
public static StringBuffer createStringBuffer(String s2, String s2){
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
}
```

上述代码中，如果想要 StringBuffer sb 不逃出方法，可以这样写：

```java
public static String createStringBuffer(String s2, String s2){
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}
```

逃逸分析的各种情况：

```java
package com.atguigu.java2;

/**
 * 逃逸分析
 *
 *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。
 * @author shkstart
 * @create 2020 下午 4:00
 */
public class EscapeAnalysis {

    public EscapeAnalysis obj;

    /*
    方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance(){
        return obj == null? new EscapeAnalysis() : obj;
    }
    /*
    为成员属性赋值，发生逃逸
     */
    public void setObj(){
        this.obj = new EscapeAnalysis();
    }
    //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。

    /*
    对象的作用域仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
    }
    /*
    引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis1(){
        EscapeAnalysis e = getInstance();
        //getInstance().xxx()同样会发生逃逸
    }
}
```

参数设置:

* ● 在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析。
* ● 如果使用的是较早的版本，开发人员则可以通过:
  * ➢ 选项 “`-XX:+DoEscapeAnalysis`" 显式开启逃逸分析
  * ➢ 通过选项 “`-XX:+PrintEscapeAnalysis`" 查看逃逸分析的筛选结果。
    * （实测这个参数不被识别，报错 `Unrecognized VM option 'PrintEscapeAnalysis'` 创建 JVM 失败，需要使用带 debug 的 JDK，例如第三方编译的 `java-1.8.0-openjdk-fastdebug-1.8.0.111-1.b15.ojdkbuild.windows.x86_64.zip` ）

结论：**开发中能使用局部变量的，就不要使用在方法外定义。**

### 逃逸分析：代码优化

使用逃逸分析，编译器可以对代码做如下优化:

* 一、**栈上分配**。将堆分配转化为栈分配。如果-一个对象在子程序中被分配, 要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
* 二、**同步省略**。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
* 三、**分离对象或标量替换**。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是存储在 CPU 寄存器中。

#### 代码优化之栈上分配

* JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。
* 常见的栈上分配的场景
  * ➢ 在逃逸分析中，已经说明了。逃逸出方法：分别是给成员变量赋值、方法返回值、实例引用传递。

代码演示：

```java
package com.atguigu.java2;

/**
 * 栈上分配测试
 * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  10:31
 */
public class StackAllocation {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 10000000; i++) {
            alloc();
        }
        // 查看执行时间
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为： " + (end - start) + " ms");
        // 为了方便查看堆内存中对象个数，线程sleep
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
    }

    private static void alloc() {
        User user = new User();//未发生逃逸
    }

    static class User {

    }
}
```

两种情况下运行，使用 VisualVM Sampler 查看 Memory 情况。

设置 VM options 为 `-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails`, 运行;

```java
花费的时间为： 97 ms
Heap
 PSYoungGen      total 305664K, used 188744K [0x00000007aab00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 262144K, 72% used [0x00000007aab00000,0x00000007b63521c8,0x00000007bab00000)
  from space 43520K, 0% used [0x00000007bd580000,0x00000007bd580000,0x00000007c0000000)
  to   space 43520K, 0% used [0x00000007bab00000,0x00000007bab00000,0x00000007bd580000)
 ParOldGen       total 699392K, used 0K [0x0000000780000000, 0x00000007aab00000, 0x00000007aab00000)
  object space 699392K, 0% used [0x0000000780000000,0x0000000780000000,0x00000007aab00000)
 Metaspace       used 3608K, capacity 4540K, committed 4864K, reserved 1056768K
  class space    used 399K, capacity 428K, committed 512K, reserved 1048576K
```

![关闭逃逸分析](StackAllocation1.png)

对比 VM options 为 `-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails`, 运行。

```java
花费的时间为： 4 ms
Heap
 PSYoungGen      total 305664K, used 78643K [0x00000007aab00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 262144K, 30% used [0x00000007aab00000,0x00000007af7ccfd8,0x00000007bab00000)
  from space 43520K, 0% used [0x00000007bd580000,0x00000007bd580000,0x00000007c0000000)
  to   space 43520K, 0% used [0x00000007bab00000,0x00000007bab00000,0x00000007bd580000)
 ParOldGen       total 699392K, used 0K [0x0000000780000000, 0x00000007aab00000, 0x00000007aab00000)
  object space 699392K, 0% used [0x0000000780000000,0x0000000780000000,0x00000007aab00000)
 Metaspace       used 8857K, capacity 9194K, committed 9344K, reserved 1056768K
  class space    used 1037K, capacity 1132K, committed 1152K, reserved 1048576K
```

![开启逃逸分析](StackAllocation2.png)

从上面可以看出是否开启逃逸分析时的内存占用情况，开启了逃逸分析内存占用明显降低，由于使用了栈上分配，不用维护 1000 万个 User 对象了，而且创建 1000 万个 User 对象所用时间也明显降低。

在 Windows (使用的是上面提到的 fastdebug JDK，否则 `+PrintEscapeAnalysis` 不可用) 中运行上述程序，打印逃逸分析日志：

```PowerShell
PS C:\Users\yan\java> java -Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+PrintEscapeAnalysis 'StackAllocation'

======== Connection graph for  StackAllocation::alloc
JavaObject NoEscape(NoEscape) [ [ 36 ]]   24    Allocate        ===  5  6  7  8  1 ( 22  20  21  1  1 ) [[ 25  26  27  34  35  36 ]]  rawptr:NotNull ( int:>=0, java/lang/Object:NotNull *, bool, top ) StackAllocation::alloc @ bci:0 !jvms: StackAllocation::alloc @ bci:0
LocalVar [ 24P [ ]]   36        Proj    ===  24  [[ 37 ]] #5 !jvms: StackAllocation::alloc @ bci:0


======== Connection graph for  StackAllocation::main
JavaObject NoEscape(NoEscape) [ [ 119 ]]   107  Allocate        ===  86  76  103  8  1 ( 32  105  20  1  1  29  1  79  1  1  1 ) [[ 108  109  110  117  118  119 ]]  rawptr:NotNull ( int:>=0, java/lang/Object:NotNull *, bool, top ) StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12
LocalVar [ 107P [ ]]   119      Proj    ===  107  [[ 120 ]] #5 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12

花费的时间为： 15 ms

======== Connection graph for  StackAllocation::main
JavaObject NoEscape(NoEscape) [ [ 98 ]]   86    Allocate        ===  366  68  358  8  1 ( 84  83  26  1  1  24  1  70  1  1  1 ) [[ 87  88  89  96  97  98 ]]  rawptr:NotNull ( int:>=0, java/lang/Object:NotNull *, bool, top ) StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12
LocalVar [ 86P [ ]]   98        Proj    ===  86  [[ 99 ]] #5 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12

Heap
 PSYoungGen      total 305664K, used 36700K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 262144K, 14% used [0x00000000eab00000,0x00000000eced7188,0x00000000fab00000)
  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)
  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)
 ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)
  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)
 Metaspace       used 2885K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 273K, capacity 386K, committed 512K, reserved 1048576K

PS C:\Users\yan\java> java -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+PrintEscapeAnalysis 'StackAllocation'
花费的时间为： 47 ms
Heap
 PSYoungGen      total 305664K, used 167772K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 262144K, 64% used [0x00000000eab00000,0x00000000f4ed72c8,0x00000000fab00000)
  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)
  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)
 ParOld
```

如果将 heap 的大小设置为 256M , 并且不使用逃逸分析，可以看到发生了 GC：

```PowerShell
PS C:\Users\yan\java> java -Xmx256M -Xms256M -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+PrintEscapeAnalysis 'StackAllocation'
[GC (Allocation Failure) [PSYoungGen: 65536K->760K(76288K)] 65536K->768K(251392K), 0.0093114 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC (Allocation Failure) [PSYoungGen: 66296K->688K(76288K)] 66304K->696K(251392K), 0.0071857 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
花费的时间为： 63 ms
Heap
 PSYoungGen      total 76288K, used 29524K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 65536K, 44% used [0x00000000fab00000,0x00000000fc729048,0x00000000feb00000)
  from space 10752K, 6% used [0x00000000ff580000,0x00000000ff62c040,0x0000000100000000)
  to   space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)
 ParOldGen       total 175104K, used 8K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)
  object space 175104K, 0% used [0x00000000f0000000,0x00000000f0002000,0x00000000fab00000)
 Metaspace       used 2885K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 273K, capacity 386K, committed 512K, reserved 1048576K
```

如果将 heap 的大小设置为 256M , 开启使用逃逸分析，可以看到没有发生 GC ：

```PowerShell
PS C:\Users\yan\java> java -Xmx256M -Xms256M -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+PrintEscapeAnalysis 'StackAllocation'

======== Connection graph for  StackAllocation::alloc
JavaObject NoEscape(NoEscape) [ [ 36 ]]   24    Allocate        ===  5  6  7  8  1 ( 22  20  21  1  1 ) [[ 25  26  27  34  35  36 ]]  rawptr:NotNull ( int:>=0, java/lang/Object:NotNull *, bool, top ) StackAllocation::alloc @ bci:0 !jvms: StackAllocation::alloc @ bci:0
LocalVar [ 24P [ ]]   36        Proj    ===  24  [[ 37 ]] #5 !jvms: StackAllocation::alloc @ bci:0


======== Connection graph for  StackAllocation::main
JavaObject NoEscape(NoEscape) [ [ 119 ]]   107  Allocate        ===  86  76  103  8  1 ( 32  105  20  1  1  29  1  79  1  1  1 ) [[ 108  109  110  117  118  119 ]]  rawptr:NotNull ( int:>=0, java/lang/Object:NotNull *, bool, top ) StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12
LocalVar [ 107P [ ]]   119      Proj    ===  107  [[ 120 ]] #5 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12

花费的时间为： 31 ms
======== Connection graph for
 StackAllocation::main
JavaObject NoEscape(NoEscape) [ [ 98 ]]   86    Allocate        ===  366  68  358  8  1 ( 84  83  26  1  1  24  1  70  1  1  1 ) [[ 87  88  89  96  97  98 ]]  rawptr:NotNull ( int:>=0, java/lang/Object:NotNull *, bool, top ) StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12
LocalVar [ 86P [ ]]   98        Proj    ===  86  [[ 99 ]] #5 !jvms: StackAllocation::alloc @ bci:0 StackAllocation::main @ bci:12

Heap
 PSYoungGen      total 76288K, used 26214K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 65536K, 40% used [0x00000000fab00000,0x00000000fc499a88,0x00000000feb00000)
  from space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000)
  to   space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)
 ParOldGen       total 175104K, used 0K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)
  object space 175104K, 0% used [0x00000000f0000000,0x00000000f0000000,0x00000000fab00000)
 Metaspace       used 2885K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 273K, capacity 386K, committed 512K, reserved 1048576K
PS C:\Users\yan\java>
```

#### 代码优化之同步省略（消除）

* 线程同步的代价是相当高的，同步的后果是降低并发性和性能。
* 在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来**判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程**。如果（是上述情况、）没有（被发布到其他线程），那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫**锁消除**。

如以下代码:

```java
public void f() {
    Object hollis = new Object();
    synchronized(hollis){
        System.out.println(hollis);
    }
}
```

代码中对 hollis 这个对象进行加锁，但是 hollis 对象的生命周期只在 f() 方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉。优化成:

```java
public void f(){
    Object hollis = new Object();
    System.out.println(hollis);
}
```

实际上，上面这么写也起不到同步作用，因为使用本地局部变量当作锁对象，每个进程调用这个方法都会 new 一个新的锁对象，从而每个线程所使用的对象监视器都是不同的，起不到同步的作用。  
而且，上面那种写法 javac 编译阶段生成的字节码中还是会有同步的字节码指令生成 （ `monitorenter` 和 `monitorexit` ）。f() 对应字节码指令如下：

```java
 0 new #2 <java/lang/Object>
 3 dup
 4 invokespecial #1 <java/lang/Object.<init>>
 7 astore_1
 8 aload_1
 9 dup
10 astore_2
11 monitorenter
12 getstatic #3 <java/lang/System.out>
15 aload_1
16 invokevirtual #4 <java/io/PrintStream.println>
19 aload_2
20 monitorexit
21 goto 29 (+8)
24 astore_3
25 aload_2
26 monitorexit
27 aload_3
28 athrow
29 return
```

#### 🌿 代码优化之标量替换

**标量 (Scalar)** 是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。

相对的，那些还可以分解的数据叫做**聚合量 (Aggregate)** ，Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若千个其中包含的若干个成员变量来代替。这个过程就是**标量替换**。

```java
public static void main(String[] args) {
    alloc();
}
private static void alloc() {
    Point point = new Point(1,2);
    System.out.println("point.x=" + point.x + "; point.y=" + point.y);
}
class Point{
    private int x;
    private int y;
}
```

以上代码，经过标量替换后，就会变成:

```java
private static void alloc() {
    int x = 1;
    int y = 2;
    System.out.println("point.x=" + x + "; point.y=" + y);
}
```

可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

标量替换为栈上分配提供了很好的基础。

**标量替换参数设置**:

参数 `-XX:+EliminateAllocations` : 开启了标量替换(默认打
开)，允许将对象打散分配在栈上。

测试：

```java
package com.atguigu.java2;

/**
 * 标量替换测试
 *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations
 * @author shkstart  shkstart@126.com
 * @create 2020  12:01
 */
public class ScalarReplace {
    public static class User {
        public int id;
        public String name;
    }

    public static void alloc() {
        User u = new User();//未发生逃逸
        u.id = 5;
        u.name = "www.atguigu.com";
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000000; i++) {
            alloc();
        }
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为： " + (end - start) + " ms");
    }
}

/*
class Customer{
    String name;
    int id;
    Account acct;

}

class Account{
    double balance;
}
 */
```

上述代码在主函数中进行了 10000000 次 alloc() 。 调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 152 MB。如果堆空间小于这个值，就必然会发生 GC。 使用如下参数运行上述代码:  

`-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations +PrintEliminateAllocations`  

这里使用参数如下:  

* ● 参数 `-server`: 启动 server 模式， 因为在 Server 模式下，才可以启用逃逸分析 (不用手动写这个参数是因为使用 `java -version` 可以查看到 JDK 版本默认就是 Server VM)。  
* ● 参数 `-XX:+DoEscapeAnalysis` : 启用逃逸分析  
* ● 参数 `-Xmx10m` : 指定了堆空间最大为 10MB  
* ● 参数 `-XX:+PrintGC` : 将打印 GC 日志。  
* ● 参数 `-XX:+EliminateAllocations` : 开启了标量替换 (默认打开)，允许将对象打散分配在栈上，比如对 象拥有 id 和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。  
* `+PrintEliminateAllocations` : 打印标量替换信息，Non-product builds: Print out when allocations are eliminated，非产品版本，需要使用 debug JDK 运行。

设置 VM options 为 `-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations`，先不使用标量替换 `-XX:-EliminateAllocations`，运行上述程序：

```java
[GC (Allocation Failure)  25600K->584K(98304K), 0.0015866 secs]
[GC (Allocation Failure)  26184K->616K(98304K), 0.0014574 secs]
[GC (Allocation Failure)  26216K->520K(98304K), 0.0013473 secs]
[GC (Allocation Failure)  26120K->536K(98304K), 0.0012746 secs]
[GC (Allocation Failure)  26136K->456K(98304K), 0.0013713 secs]
[GC (Allocation Failure)  26056K->480K(101376K), 0.0016144 secs]
[GC (Allocation Failure)  32224K->440K(101376K), 0.0015301 secs]
[GC (Allocation Failure)  32184K->440K(101376K), 0.0011484 secs]
花费的时间为： 82 ms

Process finished with exit code 0
```

设置 VM options 为 `-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations`，使用标量替换 `-XX:+EliminateAllocations`，再次运行上述程序：

```java
花费的时间为： 4 ms

Process finished with exit code
```

从程序的运行结果对比来看，开启标量替换时，没有发生垃圾回收，而且执行 `alloc()` 方法创建对象 1000 万次的时间很明显降低了。

#### 逃逸分析小结

逃逸分析小结:逃逸分析并不成熟

* 关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。
* 其根本原因就是 **无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程**。
* 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
* 虽然这项技术并不十分成熟，但是它也**是即时编译器优化技术中一个十分重要的手段**。
* 注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。
  * 前面演示的程序之所以会有栈上分配的那种效果，可以理解为：逃逸分析 + 标量替换 => 栈上分配；基于逃逸分析和标量替换，某种程度上可以说是达到了栈上分配的效果。
* 目前很多书籍还是基于 JDK 7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。

## 本章小结

* 年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。
* 老年代放置长生命周期的对象，通常都是从 Survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。
* 当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC。当 GC 发生在老年代时则被称为 Major GC 或者 Full GC。一般的，Minor GC 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。
